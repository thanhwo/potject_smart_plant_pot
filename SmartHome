#define BLYNK_TEMPLATE_ID "TMPL69RLnAsWY"
#define BLYNK_TEMPLATE_NAME "Smarth"
#define BLYNK_AUTH_TOKEN "BVNuiOIoCI5yycSayX7Wsqbs5PMk0N_K"

#include <WiFi.h>
#include <BlynkSimpleEsp32.h>
#include <Wire.h>
#include <LiquidCrystal_I2C.h>
#include <SPI.h>
#include <MFRC522.h>
#include <ESP32Servo.h>
#include <BLEDevice.h>
#include <BLEUtils.h>
#include <BLEServer.h>

// ==== BLE setup ====
BLECharacteristic *pBLECharacteristic;
std::string bleStatus = "‚è≥ ƒêang ch·ªù d·ªØ li·ªáu t·ª´ BLE...";
bool newBLEDataReceived = false;
String bleReceivedData = "";
bool wifiReady = false;

class BLECallback : public BLECharacteristicCallbacks {
  void onWrite(BLECharacteristic *pCharacteristic) override {
    std::string value = pCharacteristic->getValue();
    if (value.length() > 0) {
      bleReceivedData = String(value.c_str());
      bleReceivedData.trim();
      newBLEDataReceived = true;

      Serial.println("üì• ƒê√£ nh·∫≠n qua BLE:");
      Serial.println(bleReceivedData);
      
      // bleStatus = "‚úÖ ƒê√£ nh·∫≠n d·ªØ li·ªáu BLE!";
      pCharacteristic->setValue(bleStatus);
      pCharacteristic->notify();
    }
  }

  void onRead(BLECharacteristic *pCharacteristic) override {
    pCharacteristic->setValue(bleStatus);
    Serial.println("üì§ BLE Read ‚Üí g·ª≠i tr·∫°ng th√°i: " + String(bleStatus.c_str()));
  }
};

void setupBLE() {
  BLEDevice::init("Home Home");
  BLEServer *pServer = BLEDevice::createServer();
  BLEService *pService = pServer->createService("12345678-1234-1234-1234-1234567890ab");

  pBLECharacteristic = pService->createCharacteristic(
    "abcdefab-1234-5678-90ab-abcdefabcdef",
    BLECharacteristic::PROPERTY_WRITE |
    BLECharacteristic::PROPERTY_READ |
    BLECharacteristic::PROPERTY_NOTIFY
  );

  pBLECharacteristic->setCallbacks(new BLECallback());
  pService->start();
  BLEAdvertising *pAdvertising = BLEDevice::getAdvertising();
  pAdvertising->start();

  Serial.println("üîµ BLE s·∫µn s√†ng. G·ª≠i 'SSID,PASS' t·ª´ LightBlue/nRF Connect");
}

// ==== Blynk ·∫£o & ph·∫ßn c·ª©ng ====
#define VIRTUAL_TEMP V0
#define VIRTUAL_HUMID V1
#define VIRTUAL_DOOR V5

#define SS_PIN 5
#define RST_PIN 16
#define BUZZER_PIN 12
#define PIN_SG90 27
#define PIN_SG90_2 13  // Servo 2 c·∫Øm v√†o ch√¢n D13
#define RAIN_SENSOR_PIN 34  // C·∫£m bi·∫øn m∆∞a c·∫Øm v√†o ch√¢n D34

MFRC522 mfrc522(SS_PIN, RST_PIN);
LiquidCrystal_I2C lcd(0x27, 16, 2);
Servo sg90, sg90_2;  // Servo th·ª© 2

byte validUID1[4] = {0x13, 0xA2, 0x1A, 0x2D};
byte validUID2[4] = {0x5A, 0xB2, 0xB5, 0x02};

bool doorOpen = false;
String ssid_input = "";
String password_input = "";

// === WiFi connection ===
void setup_wifi() {
  WiFi.begin(ssid_input.c_str(), password_input.c_str());
  Serial.print("üì∂ ƒêang k·∫øt n·ªëi t·ªõi WiFi: ");
  Serial.println(ssid_input);
  int retry = 0;
  while (WiFi.status() != WL_CONNECTED && retry < 20) {
    delay(500);
    Serial.print(".");
    retry++;
  }

  if (WiFi.status() == WL_CONNECTED) {
    Serial.println("\n‚úÖ ƒê√£ k·∫øt n·ªëi WiFi!");
    wifiReady = true;
    bleStatus = "‚úÖ K·∫øt n·ªëi WiFi th√†nh c√¥ng!";  // Th√¥ng b√°o WiFi th√†nh c√¥ng
  } else {
    Serial.println("\n‚ùå K·∫øt n·ªëi WiFi th·∫•t b·∫°i!");
    bleStatus = "‚ùå K·∫øt n·ªëi WiFi th·∫•t b·∫°i!";  // Th√¥ng b√°o WiFi th·∫•t b·∫°i
  }

  // G·ª≠i th√¥ng b√°o tr·∫°ng th√°i WiFi qua BLE
  pBLECharacteristic->setValue(bleStatus);
  pBLECharacteristic->notify();
}

// === RFID & Servo ===
bool compareUID(byte *cardUID, byte *targetUID) {
  for (byte i = 0; i < 4; i++) {
    if (cardUID[i] != targetUID[i]) return false;
  }
  return true;
}

void beep(int duration) {
  digitalWrite(BUZZER_PIN, HIGH);
  delay(duration);
  digitalWrite(BUZZER_PIN, LOW);
}

void saveDoorState(bool state) { doorOpen = state; }

void restoreDoorState() {
  if (doorOpen) {
    sg90.write(0);
    doorOpen = false;
    Serial.println("üõ† C·ª≠a ƒë√≥ng l·∫°i theo tr·∫°ng th√°i c≈©");
    lcd.clear();
    lcd.setCursor(0, 0);
    lcd.print("Door closed");
  }
}

void checkRFID() {
  if (!mfrc522.PICC_IsNewCardPresent() || !mfrc522.PICC_ReadCardSerial()) {
    lcd.setCursor(0, 0);
    lcd.print("Scan card...     ");  // Th√™m d·∫•u c√°ch ƒë·ªÉ x√≥a d√≤ng c≈©
    return;
  }

  Serial.print("UID: ");
  lcd.clear();
  lcd.setCursor(0, 0);
  lcd.print("UID: ");

  for (byte i = 0; i < mfrc522.uid.size; i++) {
    Serial.print(mfrc522.uid.uidByte[i] < 0x10 ? " 0" : " ");
    Serial.print(mfrc522.uid.uidByte[i], HEX);
    lcd.print(mfrc522.uid.uidByte[i], HEX);
    lcd.print(" ");
  }
  Serial.println();

  if (compareUID(mfrc522.uid.uidByte, validUID1) || compareUID(mfrc522.uid.uidByte, validUID2)) {
    Serial.println("‚úÖ Truy c·∫≠p h·ª£p l·ªá");
    lcd.clear();
    lcd.setCursor(0, 0);
    lcd.print("Access Granted");
    beep(200);
    delay(2000);

    sg90.write(180);
    saveDoorState(true);
    delay(5000);
    sg90.write(0);
    saveDoorState(false);

    Serial.println("üîí C·ª≠a ƒë√£ ƒë√≥ng");
    lcd.clear();
    lcd.setCursor(0, 0);
    lcd.print("Door closed");
  } else {
    Serial.println("‚ùå Th·∫ª kh√¥ng h·ª£p l·ªá");
    lcd.clear();
    lcd.setCursor(0, 0);
    lcd.print("Access Denied");
    beep(500);
  }

  mfrc522.PICC_HaltA();
}


void readSensors() {
  int temperature = random(20, 35);
  int humidity = random(40, 80);
  Serial.print("üå° Temp: "); Serial.println(temperature);
  Serial.print("üíß Humi: "); Serial.println(humidity);
  Blynk.virtualWrite(VIRTUAL_TEMP, temperature);
  Blynk.virtualWrite(VIRTUAL_HUMID, humidity);
  delay(500);  // Gi·∫£m delay ƒë·ªÉ kh√¥ng block loop
}
void setup() {
  Serial.begin(115200);
  pinMode(BUZZER_PIN, OUTPUT);
  pinMode(RAIN_SENSOR_PIN, INPUT);  // Thi·∫øt l·∫≠p c·∫£m bi·∫øn m∆∞a l√† input

  lcd.init();
  lcd.backlight();
  lcd.setCursor(0, 0);
  lcd.print("üîã Khoi dong...");

  SPI.begin();
  mfrc522.PCD_Init();

  sg90.attach(PIN_SG90, 500, 2400);
  sg90_2.attach(PIN_SG90_2, 500, 2400); // G·∫Øn servo 2

  sg90.write(0);
  sg90_2.write(0);

  setupBLE();  // B·∫Øt ƒë·∫ßu BLE

  Serial.println("‚úÖ ƒê√£ kh·ªüi ƒë·ªông xong!");
}

void loop() {
  // üì° X·ª≠ l√Ω d·ªØ li·ªáu BLE n·∫øu ch∆∞a c√≥ WiFi
  if (!wifiReady && newBLEDataReceived) {
    if (bleReceivedData.indexOf(',') != -1) {
      int splitIndex = bleReceivedData.indexOf(',');
      ssid_input = bleReceivedData.substring(0, splitIndex);
      password_input = bleReceivedData.substring(splitIndex + 1);
      ssid_input.trim();
      password_input.trim();

      Serial.println("üì° ƒêang k·∫øt n·ªëi v·ªõi:");
      Serial.println("SSID: " + ssid_input);
      Serial.println("PASS: " + password_input);

      setup_wifi();
      if (wifiReady) {
        Blynk.begin(BLYNK_AUTH_TOKEN, ssid_input.c_str(), password_input.c_str());
        lcd.clear();
        lcd.setCursor(0, 0);
        lcd.print("WiFi OK. Blynk on");
        delay(1000);
        restoreDoorState();
      }
    }
  }

  // üîÑ C√°c t√°c v·ª• khi ƒë√£ c√≥ WiFi
  if (wifiReady) {
    Blynk.run();
    readSensors();
    checkRFID();
  }

  // üåß Ki·ªÉm tra c·∫£m bi·∫øn m∆∞a ‚Äî lu√¥n ch·∫°y k·ªÉ c·∫£ khi ch∆∞a c√≥ WiFi
  int rainState = digitalRead(RAIN_SENSOR_PIN);
  Serial.print("üìä Tr·∫°ng th√°i c·∫£m bi·∫øn m∆∞a (digital): ");
  Serial.println(rainState);

  if (rainState == LOW) {
    Serial.println("üåß C√≥ m∆∞a ‚Üí servo 2 quay 90 ƒë·ªô");
    sg90_2.write(90);
  } else {
    Serial.println("‚òÄÔ∏è Kh√¥ng m∆∞a ‚Üí servo 2 quay v·ªÅ 0 ƒë·ªô");
    sg90_2.write(0);
  }

  delay(200);  // Cho loop ch·∫°y nh·∫π nh√†ng, kh√¥ng qu√° d√†y
}
